现在有很多的网站都需要进行扫码登录，才能进行相关的搜索操作，比如京东，淘宝等等，如果采用手动登录的方式则会特别麻烦，代码实现起来难度系数高，且维护成本大，利用已有的浏览器配置和登录信息，我们可以避免重复登录的繁琐步骤，并且能够更好地模拟真实用户的行为。然而，这种方式也带来了一些挑战，比如浏览器会显示正在受到自动化测试程序的控制，可能会被某些网站检测并阻止。本章将详细介绍如何使用Playwright启用本地浏览器和登录态，以及如何连接远程浏览器。

### 16.3.1 指定本地浏览器和用户数据
用本地浏览器是一种常见的方法，它允许我们利用已有的浏览器配置和登录信息，从而简化和绕过登录的流程。以下是详细的步骤和示例代码。

> **优点：写起来简单一些，可以使用已有的浏览器配置和登录信息。**
>
> **缺点：浏览器会显示正在受到自动化测试程序的控制(可能会有网站针对性进行反爬)**
>

```python
from playwright.sync_api import sync_playwright

with sync_playwright() as pw:
    # 启动本地的chrome浏览器
    browser = pw.chromium.launch_persistent_context(
        # 用户数据路径文件
        user_data_dir=r'C:\Users\admin\AppData\Local\Google\Chrome\User Data',
        # 谷歌浏览器的路径
        executable_path=r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        # 显示浏览器的界面
        headless=False
    )
    # 创建页面
    page = browser.new_page()

    # 添加初始化js脚本代码，隐藏webdriver属性，防止检测出来
    js = "Object.defineProperties(navigator, {webdriver:{get:()=>undefined}});"
    page.add_init_script(js)

    # 访问网站
    page.goto('https://www.taobao.com')

    # 关闭浏览器
    browser.close()
```

**详细说明:**

+ `launch_persistent_context`: 启动一个持久化的浏览器上下文，保留用户数据和配置。
+ `user_data_dir`: 指定Chrome的用户数据目录路径，通常包含登录信息、书签、扩展等。
+ `executable_path`: 指定Chrome浏览器的可执行文件路径。
+ `headless`: 设置为False以显示浏览器界面，便于调试。

**注意事项:**

+ 确保指定的用户数据目录路径正确，并且包含有效的登录信息。
+ 在某些情况下，网站可能会检测到webdriver属性，因此需要通过`add_init_script`方法隐藏该属性。

### 16.3.2 使用本地登录的用户信息启动淘宝
```python
from playwright.sync_api import sync_playwright

with sync_playwright() as pw:
    # 创建浏览器
    browser = pw.chromium.launch_persistent_context(
        # 用户数据路径文件
        user_data_dir=r'C:\Users\Administrator\AppData\Local\Google\Chrome\User Data',
        # 谷歌浏览器的路径
        executable_path=r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        # 显示浏览器的界面
        headless=False
    )
    # 创建页面
    page = browser.new_page()

    # 添加初始化js脚本代码，隐藏webdriver属性，防止检测出来
    js = "Object.defineProperties(navigator, {webdriver:{get:()=>undefined}});"
    page.add_init_script(js)

    # 访问网站
    page.goto('https://www.taobao.com')

    # 等待页面加载完成
    page.wait_for_load_state('networkidle')

    # 打印页面标题
    print("页面标题:", page.title())
```

**详细说明:**

+ `wait_for_load_state('networkidle')`: 等待页面加载完成，确保所有资源加载完毕。
+ `page.title()`: 获取页面的标题，用于验证页面是否正确加载。

**注意事项:**

+ 确保用户数据目录包含有效的登录信息，否则可能需要手动登录。
+ 通过`add_init_script`方法隐藏webdriver属性，防止被网站检测。

### 16.3.3 调试模式启动浏览器
在某些情况下，我们可能需要连接到一个已经运行的浏览器实例，而不是每次都启动一个新的浏览器。Playwright提供了`connect_over_cdp`方法，可以连接到通过`Chrome DevTools Protocol(CDP)`启动的远程浏览器。

首先，我们需要启动一个Chrome浏览器实例，并启用远程调试端口。

```python
import subprocess

# 浏览器所在路径
chrome_path = r'"C:\Program Files\Google\Chrome\Application\chrome.exe"'
debugging_port = "--remote-debugging-port=7899"
command = f"{chrome_path} {debugging_port}"
subprocess.Popen(command, shell=True)
```

**详细说明:**

+ `subprocess.Popen`: 启动一个新的进程来运行Chrome浏览器，并启用远程调试端口。
+ `--remote-debugging-port=7899`: 指定远程调试端口为7899。

**注意事项:**

+ 确保指定的Chrome路径正确。
+ 确保端口7899未被其他进程占用。

### 16.3.4 连接远程浏览器
接下来，我们使用Playwright连接到已经启动的Chrome浏览器实例，并进行一些基本操作。

```python
import time
from playwright.sync_api import sync_playwright

with sync_playwright() as playwright:
    # 连接到本地chrome浏览器
    browser = playwright.chromium.connect_over_cdp("http://localhost:7899")
    # 获取浏览器上下文
    context = browser.contexts[0]
    # 新建一个页面
    page = context.new_page()
    # 打开淘宝
    page.goto("https://www.taobao.com/")
    # 等待10秒
    time.sleep(10)
    # 关闭浏览器
    browser.close()

if __name__ == '__main__':
    BaseSpider().main()
```

**详细说明:**

+ `connect_over_cdp`: 通过CDP连接到已经启动的Chrome浏览器实例。
+ `contexts[0]`: 获取浏览器的第一个上下文。
+ `new_page`: 创建一个新的页面。
+ `goto`: 导航到指定的URL。
+ `wait_for_load_state('networkidle')`: 等待页面加载完成。
+ `page.title()`: 获取页面的标题，用于验证页面是否正确加载。

**注意事项:**

+ 确保浏览器已经成功启动并启用远程调试端口。
+ 等待浏览器启动完成后再进行连接，可以使用`time.sleep`来确保浏览器已经准备好。

