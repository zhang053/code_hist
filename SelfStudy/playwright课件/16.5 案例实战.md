在本节中，我们将详细介绍如何使用 Playwright 进行天气数据抓取，并分析页面数据。通过 Playwright 的强大功能，我们可以轻松地处理复杂的动态页面，并将数据存储到 MongoDB 中。以下是详细的步骤和示例代码。

### 16.5.1 目标网站
网站地址：[https://lishi.tianqi.com/changsha/202501.html](https://lishi.tianqi.com/changsha/202501.html)

![图 16.5.1-1 网站页面](https://cdn.nlark.com/yuque/0/2025/jpeg/48857405/1741420636993-a4727163-40cf-4b80-b163-319097c6b27f.jpeg)

### 16.5.2 页面数据分析
在进行数据抓取之前，我们需要先分析目标网站的页面结构，确定需要抓取的数据字段。以下是页面数据分析的详细步骤。首先，打开目标网站并使用浏览器的开发者工具（通常是按 F12 或右键选择“检查”）来查看页面的 HTML 结构，如图 16.5.2-1 所示。

![](https://cdn.nlark.com/yuque/0/2025/jpeg/48857405/1741420873316-a0fdd713-2e5c-4742-b071-c4a01a951d1d.jpeg)

图 16.5.2-1 F12查看 

确定要采集的目标数据字段如下：

    - 日期 (date)
    - 最高气温 (max_tem)
    - 最低气温 (min_tem)
    - 天气 (condition)
    - 风向 (windy)

### 16.5.3 案例代码实现
下面我们开始使用 Playwright 来采集天气网的数据，并将其保存到 MongoDB 数据库中。通过这个案例，你可以学习到 Playwright 的基本用法以及如何处理动态加载的内容。

#### 1）环境准备
首先，我们需要导入必要的库并连接到 MongoDB 数据库：

```python
from playwright.sync_api import sync_playwright
import pymongo

city = input('请输入你要查询的城市(拼音全称):')
year = input('请输入你要查询的年份:')

# 1.连接到mongodb
client = pymongo.MongoClient("localhost", 27017)

# 2.选中数据库
db = client['weather']

# 3.指定集合
col = db[f'{city}_{year}']
```

这段代码通过`pymongo`库实现与MongoDB数据库的动态交互，首先获取用户输入的城市拼音（如`beijing`）和年份（如`2023`），随后连接到本地MongoDB服务（默认地址`localhost:27017`），选择名为`weather`的数据库（若不存在则自动创建），最后根据输入参数动态生成并指定集合名称（如`beijing_2023`），其核心目的是为后续存储或查询特定城市及年份的天气数据构建结构化存储容器，通过集合名称的拼接实现数据按城市和年份分类管理，为数据爬取与持久化提供基础支持。



####  2）初始化 Playwright
接下来，我们初始化 Playwright 并启动浏览器：

```python
with sync_playwright() as p:
    # 1.创建浏览器
    broswer = p.chromium.launch(headless=False)

    # 2.创建上下文
    context = broswer.new_context()

    # 3.创建页面
    page = context.new_page()
    # 添加初始化js脚本代码，隐藏webdriver属性，防止检测出来
    js = "Object.defineProperties(navigator, {webdriver:{get:()=>undefined}});"
    page.add_init_script(js)
```

为了防止被网站识别为自动化工具，我们在页面加载时添加了一段 JavaScript 脚本来隐藏 `navigator.webdriver`属性。

#### 3）访问目标页面
然后，使用 `page.goto`方法导航（跳转）到指定的历史天气页面URL，其中`{city}`和 `{year}`分别代表城市和年份变量。

```python
page.goto(f"https://lishi.tianqi.com/{city}/{year}01.html")
```

#### 4）抓取天气信息
接下来是核心部分：遍历多页天气数据列表并提取每一页的天气数据：

```python
   for i in range(1,13):
        print(f'开始抓取第{i}月天气数据')
        page.wait_for_timeout(2000)

        # 1.先定位到指定元素，再调用  scroll_into_view_if_needed()
        page.locator('//div[@class="lishidesc2"]').scroll_into_view_if_needed()
        page.wait_for_timeout(1000)
        page.click('//div[@class="lishidesc2"]')
        page.wait_for_timeout(1000)
        li_list = page.locator('//ul[@class="thrui"]/li').all()
        # print(len(li_list),li_list)
        # 遍历每一个tr元素，并提取每一个tr元素对应的文本值
        for li in li_list:
            date = li.locator('//div[@class="th200"]').inner_text()
            max_tem = li.locator('//div[@class="th140"]').nth(0).inner_text()
            min_tem = li.locator('//div[@class="th140"]').nth(1).inner_text()
            condition = li.locator('//div[@class="th140"]').nth(2).inner_text()
            windy = li.locator('//div[@class="th140"]').nth(3).inner_text()
            dict_ = {
                "日期": date,
                "最高气温": max_tem,
                "最低气温": min_tem,
                "天气": condition,
                "风向": windy
            }
            print(dict_)
            col.insert_one(dict_)

        # 点击下一页
        if i < 12:
            # 滚动页面到下一页按钮可见
            page.locator('//a[@class="tian_one_h"]').scroll_into_view_if_needed()
            page.wait_for_timeout(2000)
            page.locator("#month").select_option(f"{i+1}")
```

在这个循环中，我们做了如下操作：

    - **循环遍历月份，****每次抓取一页数据**
        * `for i in range(1,13)` 控制遍历1至12月，每次循环处理一个月的天气数据
    - **页面交互与数据加载**
        * 通过 `scroll_into_view_if_needed()` 滚动页面确保目标元素可见，随后点击元素触发数据加载（如翻页或展开），并通过 `wait_for_timeout` 添加延迟避免反爬或等待渲染。
    - **数据提取与存储**
        * `li_list = page.locator('//ul[@class="thrui"]/li').all()` 定位到包含每日天气数据的列表项。
        * 遍历每个 `li` 元素，通过XPath定位具体字段（日期、最高/最低气温、天气、风向），提取文本并构建字典 `dict_`。
        * `col.insert_one(dict_)` 将每条数据插入MongoDB集合，实现持久化存储。
    - **翻页逻辑**：
        * 若当前月份非12月（`i < 12`），通过 `select_option(f"{i+1}")` 选择下拉菜单中的下一月份，模拟用户点击翻页操作，继续抓取后续月份数据。

#### 5）关闭浏览器
最后，我们等待一段时间后关闭浏览器：

```python
page.wait_for_timeout(5000) # 等待一段时间后关闭浏览器 browser.close()
```

完整代码如下：

```python
from playwright.sync_api import sync_playwright
import pymongo

city = input('请输入你要查询的城市(拼音全称):')
year = input('请输入你要查询的年份:')

# 1.连接到mongodb
client = pymongo.MongoClient("localhost", 27017)

# 2.选中数据库
db = client['weather']

# 3.指定集合
col = db[f'{city}_{year}']

with sync_playwright() as p:
    # 1.创建浏览器
    broswer = p.chromium.launch(headless=False)

    # 2.创建上下文
    context = broswer.new_context()

    # 3.创建页面
    page = context.new_page()

    js = "Object.defineProperties(navigator, {webdriver:{get:()=>undefined}});"
    page.add_init_script(js)

    # 4.访问
    page.goto(f"https://lishi.tianqi.com/{city}/{year}01.html")
    page.wait_for_timeout(2000)

    for i in range(1,13):
        print(f'开始抓取第{i}月天气数据')
        page.wait_for_timeout(2000)

        # 1.先定位到指定元素，再调用  scroll_into_view_if_needed()
        page.locator('//div[@class="lishidesc2"]').scroll_into_view_if_needed()
        page.wait_for_timeout(1000)
        page.click('//div[@class="lishidesc2"]')
        page.wait_for_timeout(1000)
        li_list = page.locator('//ul[@class="thrui"]/li').all()

        for li in li_list:
            date = li.locator('//div[@class="th200"]').inner_text()
            max_tem = li.locator('//div[@class="th140"]').nth(0).inner_text()
            min_tem = li.locator('//div[@class="th140"]').nth(1).inner_text()
            condition = li.locator('//div[@class="th140"]').nth(2).inner_text()
            windy = li.locator('//div[@class="th140"]').nth(3).inner_text()
            dict_ = {
                "日期": date,
                "最高气温": max_tem,
                "最低气温": min_tem,
                "天气": condition,
                "风向": windy
            }
            print(dict_)
            col.insert_one(dict_)

        # 点击下一页
        if i < 12:
            # 滚动页面到下一页按钮可见
            page.locator('//a[@class="tian_one_h"]').scroll_into_view_if_needed()
            page.wait_for_timeout(2000)
            page.locator("#month").select_option(f"{i+1}")


    # 等待2秒
    page.wait_for_timeout(10000)
```

运行结果，如图 16.5.3-1 所示。

![图16.5.3-1 运行结果](https://cdn.nlark.com/yuque/0/2025/jpeg/48857405/1741594848194-1c058673-83c4-44ec-b1ee-0bc377b72bbe.jpeg)

数据库保存结果，如图 16.5.3-2 所示。

![图16.5.3-2 数据库保存结果](https://cdn.nlark.com/yuque/0/2025/jpeg/48857405/1741594924655-4a803e29-454d-4c46-be2d-f3480abde75f.jpeg)

                                                                          



